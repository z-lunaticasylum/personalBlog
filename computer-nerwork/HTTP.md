**前言：本篇记录下 HTTP 相关的知识**
### 一、状态码
> 301：永久重定向  
302：临时重定向   
304：缓存重定向，告诉用户可以使用缓存的资源   
400：表示客户端的报文有错，但只是笼统的错误   
403：服务器端禁止访问资源，并不是客户端的错误   
404：请求的资源在服务器上不存在或未找到   
500：笼统的服务端器端报错   
501：客户端请求的功能还未支持   
502：服务器自身正常，但访问后端服务器时出错，一般是服务器作为代理或者网关情况下   
503：表示服务器正忙

### 二、http 常见的字段
#### 1、请求头
>Host: 请求资源的服务器（主机名）   
User-Agent: 发送请求的客户端的信息    
Accept-Encoding: 客户端能接收的编码类型/压缩格式；比如说: gzip    
Authorization：携带的认证信息   
If-Modified-Since：协商缓存中会使用到，表示浏览器缓存的对该资源文件的服务器最后修改时间；跟响应头的 Last_Modified 配合使用
#### 2、响应头
> Content-Length: 返回数据时，表示此次返回数据的长度    
Content-Type: 服务端响应时，告诉客户端数据的类型格式；例如：text/html   
Content-Encoding: 服务端响应，表示数据使用的压缩格式    
Last-Modified: 资源最后修改时间   
Connection：连接方式，是否是长连接；例如：keep-alive    
### 三、http 缓存
#### 1、强缓存
1. 涉及到http请求中两个响应头中的字段：cache-control和expires；分别表示相对时间和绝对时间；
2. 当浏览器第一次请求一个资源的时候，服务器会在响应头中加入cache-control字段，表明该资源过期时间；
3. 当浏览器再次对该资源进行请求时，浏览器会比对当前时间跟设置的过期时间，判断资源是否过期；如果没有过期，则拿浏览器缓存的资源；如果过期了，则向服务器发送请求；
4. 服务器检查资源没有更新，则返回304状态码；如果有更新，则返回200状态码以及新的资源内容 
5. 服务器会重新对 cache-control 设置时间
> * cache-control：设置时间的格式是：Cache-Control: max-age=(seconds);设置缓存存储的最大周期，超过这个时间缓存被认为过期 (单位秒)。与Expires相反，时间是相对于请求的时间。    
> * expires：设置时间的格式是：Expires: Wed, 21 Oct 2015 07:28:00 GMT；即在此时候之后，响应过期。
> * 如果在Cache-Control响应头设置了 "max-age" 或者 "s-max-age" 指令，那么 Expires 头会被忽略。
> * cache-control 值为 no-cache 和 no-store 的区别: no-cache 表示强制要求缓存把请求提交给服务器进行验证，也是开启协商缓存设置的值; no-store 表示不使用缓存
#### 2、协商缓存
1. 请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现
> * If-Modified-Since：向服务器发送请求时，携带的最后一次服务器对资源的修改时间；or 浏览器缓存记录的该文件的最后服务器修改时间
> * Last-Modified：响应头中，服务器返回的资源的最后一次修改时间
> * 在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是请求的资源，同时有一个Last-Modified 的属性字段，标记此文件在服务期端最后被修改的时间，格式类似这样：Last-Modified: Fri, 12 May 2006 18:53:33 GMT；
> * 客户端第二次请求此URL时，浏览器会向服务器传送 If-Modified-Since 报头，询问该时间之后文件是否有被修改过：　If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT
> * 服务端会拿到 If-Modified-Since ，进行判断，如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。
2. 请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段实现
> * If-None-Match：上一次请求时，服务端在返回资源时带上的 ETag 字段的内容
> * ETag ：响应头中的资源的特定版本的标识符
> * 当浏览器对某一资源再次发起请求时，发现上次对该资源请求返回的响应头中含有 Etag 字段，会在请求时将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200
### 四、http 和 https 的区别
1. http 是明文传输，而 https 中重要的一个方面是对数据传输安全性的保障，是通过对传输内容的加密来实现，主要是通过三个方面：
> * 对内容进行加密，通过一个摘要算法（其实是一个哈希函数）来算出内容的哈希值，也称为内容的指纹；这个哈希值是唯一的，并且不能通过哈希值推算内容；然后会将内容和哈希值一起发送给对方。对方接受后会对内容也通过摘要算法算出一个哈希值，对比之后如果相同，就代表是正确完整的；如果不同，就代表消息内容可能被篡改；
> * 但这样还是会有问题，就是消息内容和哈希值一起被篡改。所以就引入了非对称加密和对称加密。通过对摘要算法算出的哈希值进行非对称加密，用私钥加密，公钥解密的方式，在对哈希值进行非对称加密算法之后会生成一个数字签名。然后将消息内容、哈希值、数字签名一起发送，对方接受之后，对数字签名进行公钥解密得到一个哈希值 A，将消息内容进行摘要算法生成哈希值 B，对比两个哈希值；对传输的内容进行对称加密；    
> 因此，非对称加密是针对公钥，而对称加密是针对传输的内容。    
>   * **非对称加密**: 涉及到两个概念，公钥和私钥。公钥可以公开给所有人，私钥是自己保管，不能公开。两个密钥可以双向加解密，即可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。两种加解密的目的不太相同：
>     * 用**公钥加密，私钥解密**：因为公钥加密的内容只可以用对应的私钥解密，其他人没办法解密，所以**可以保证内容传输的安全**；
>     * 用**私钥加密，公钥解密**：因为私钥只有自己有，不会被公布，所以**可以保证消息内容不会被冒充修改**。
> * 但还存在问题是，公密钥有可能会被伪造。因此引入数字证书。服务器将公钥给到 CA（即是数字证书认证机构），CA 将公钥用 CA 自己的私钥生成一个数字签名，并颁发一个数字证书；服务端给出公钥的同时，也给出 CA 的数字签名，客户端拿到服务端给的公钥和 CA 的数字签名后，用 CA 的公钥（事先置入到浏览器或电脑中）对 CA 的数字签名解密得到公钥，判断是否一致。    

通过以上三个步骤的处理，实现了 https 的内容安全传输。第一个步骤是对传输内容的加密，防止交互信息被获取；第二个步骤是防止消息内容被篡改；第三个步骤是加入证书。   
2. https 能够实现加密传输的原因是加入了  SSL/TLS 安全协议；因此，相对于 http 在通过三次握手之后建立 TCP 连接即可进行报文传输，https 还需要进行 SSL/TLC 的握手过程，才能进行加密信息的传输   
3. 默认端口：http 是 8080，https 是 443；   
4. https 需要 CA 证书
### 五、http/1,1、http/2.0、http/3.0 各自的特点/优化点是什么
#### 1、http/1.1
1. **长连接**：基于早期的 http/1.0，提出了一个长连接的通信方式：不用每进行一次通信就来一次 TCP 连接(三次握手)。长连接是，当第一次三次握手完成后，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态；http 默认开启长连接   
2. **管道网络传输**：因为有了长连接，所以在进行多个请求时，可以连续的发送请求，而不用在发送一个请求之后，等待有响应之后再发送第二个。解决了请求的队头阻塞。但是服务器则必须是按照请求的顺序来做出响应，那么如果有一个请求的响应时间较长，后续的请求也不会进行响应，等待该请求，因此响应的队头阻塞问题依旧存在。(**现在的浏览器不再支持管道传输**)
3. **队头阻塞**：就是上面提到的问题。
#### 2、http/2.0：
1. **报文头部压缩**：如果发送多个请求，这些请求的请求头是一样或相似的，那么会消除重复的部分   
原因：报文的 Header 部分包含很多固定且重复的字段，比如说 Cookie、User Agent 等，这些字段占的字节数多且重复；因此需要压缩且避免重复性。
2. **二进制格式报文**：报文的形式不再是纯文本，而是采用二进制格式；请求头信息和数据体都是二进制，统称为帧：头信息帧、数据帧   
原因：字段是 ASCII 编码，虽然方便人观察，但效率低，所以需要改成二进制编码。
3. **并发传输**：在 http2.0 中的一条 TCP 连接中，含有多个 Stream，每个 Stream 包含一个或者多个 Message；这里的 Message 就对应着 http1 中的请求或者响应；Message 由头部和包体组成。Mesage 中包含一个或多个 Frame(也就是将一个 http 请求的消息拆分成多个 Frame)，而 Frame 是 http2.0 中的最小单位，存储着二进制形式压缩的 http1 中的内容(头部和包体)。    
每一个不同的 http 请求都有特定的 Stream ID，接收端可以通过 Stream ID 来有序组装 http 请求的内容；因此不同 Stream 中的 Frame 是可以乱序发送的，也就是说可以并发地进行传输，也就可以并行交错地进行请求和响应。
> http 请求、TCP 连接、stream、frame之间的关系：    
多个 Stream 跑在一条 TCP 连接;    
同一个 HTTP 请求与响应是跑在同一个 Stream 中;   
HTTP 消息可以由多个 Frame 构成;   
一个 Frame 可以由多个 TCP 报文构成。
4. **服务器主动推送**：服务器可以主动地向客户端推送内容；比如客户端请求了 HTML 文件后，通常都需要 CSS 文件，那么这时候服务端就可以主动推送 CSS 文件，减少客户端请求的发送。



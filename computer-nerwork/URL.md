**前言：本篇浅谈一下输入 URL 敲下回车后会发生什么**
### 输入 URL 会发生什么

#### 一、一些概念
1. **DNS 解析**：   
> DNS 即是 Domain Name System，就是域名系统服务器，保存了 web 服务器域名和 IP 的对应关系。计算机在网络上进行通讯时，是不能识别域名的，只认识 252.94.131.12 之类的IP地址。因此为了能够识别域名，就需要 DNS。DNS 将 IP 和域名相互映射，提供将域名转换成 IP 的工作服务。
2. **根域名、顶级域名、二级域名、三级域名**：   
> 举个例子：`www.baidu.com.`（最后面有一个点，通常是省略的)   
`.`：根域名   
`com`：顶级域名   
`baidu`：二级域名   
`www`：三级域名   
如果三级域名前面还有就是四级域名
3. **DNS 查询顺序**
  * 浏览器自身缓存的 DNS；
  * 操作系统的缓存；
  * 本地的 hosts 文件；
  * 如果本地的 hosts 文件也没有，就会去访问本地 DNS 服务器
  * 由本地 DNS 服务器去一步步访问：
      * 这里访问 DNS 服务器的顺序是这样的：首先访问根域名服务器 .，根域名服务器发现域名 www.baidu.com.发现顶级域名是 .com，就到 .com顶级域名服务器地址查找；
      * 来到 `.com` 顶级域名服务器地址后，进一步给到 www.baidu.com 的 DNS 服务器地址，到这个 DNS 服务器查询；
      * 最后由这个权威 DNS 服务器返回 IP 地址，拿到 IP 地址返回客户端，建立连接。
    * 向域名服务器发送请求
4. **进程、线程：**
> 进程：是 CPU 资源分配的最小单位；程序运行需要专属的内存空间，那么这块内存空间就是进程；   
线程：是 CPU 调度的最小单位；一个进程中至少包含一个线程。可以是单线程，也可以是多线程；   
**单线程**代表处理的任务是按照一定的顺序的，前面的执行完才到后面；    
**多线程**即在一个程序中可以同时运行多个不同的 线程 来执行不同的任务， 也就是说允许单个程序创建多个并行执行的 线程 来完成各自的任务   

5. **浏览器中包含的进程**
>   * Browser 进程：浏览器的主进程；主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务（比如网络线程来处理 url）
>  * 第三方插件进程：每种类型的插件对应一个进程，使用该插件时才创建
>  * 网络进程
>  * GPU 进程：用于 3d 绘制、负责渲染过程中的光栅化操作
>  * 渲染进程：用于页面渲染、脚本执行、事件处理等；每一个 tab 页面都有一个渲染进程

6. **渲染进程包含的线程**
  * GUI 渲染线程
  * js 引擎线程
  * 事件触发线程
  * 定时触发器线程
  * 异步 http 请求线程
  * 合成线程：进行渲染过程中的分块操作
  > GUI 渲染线程和 js 引擎线程是互斥的，js 引擎线程会阻塞 GUI 渲染线程的执行

#### 二、具体过程

##### 1、网络通信阶段
1. 首先是网络通信阶段。目前的计算机通信采用的是 TCP/IP 四层协议，也就是将整个的网络通信分为了四层，分别是：应用层、传输层、网络层、物理层；也有说是五层，在物理层前多分了一层数据链路层。通信的传输是从发送方自上而下到接收方的自下而上的这么一个过程。
2. 首先输入 url 敲下回车之后，浏览器会开辟一个线程来处理 url，一个 url 通常包括协议、域名、端口号、路径、请求参数等，浏览器会进行解析。接着就通过网络线程发送请求。
3. 先是应用层进行 DNS 解析。DNS 是域名系统服务器，储存了域名和 IP 地址映射关系。因为域名主要方便人们记忆和识别，而计算机在进行通信时不认识域名，只认得 IP 地址，所以需要 DNS 解析。
    * 就比如是 www.baidu.com 这个 url。首先 PC 或者手机移动端有一个 DNS 客户端，也可以称为本地域名服务器，会先去访问缓存中的域名对应的 IP 地址，首先是浏览器缓存，如果存在，那么就直接返回对应的 IP 地址； 
    * 如果不存在，那么就到操作系统缓存中查询；如果没有，就查询 host 文件，如果还没有，就会去访问 DNS 服务器。
    * 具体过程是，首先是访问根级域名服务器；根级域名服务器返回 .com 的顶级域名服务器的地址；
    * 接着顶级域名服务器再返回 www.baidu.com 权威域名服务器的地址；最后本地域名服务器就拿到了权威域名服务器返回的对应的 IP 地址。
4. 获取到 IP 地址之后，就可以进行 HTTP 请求了，发送 HTTP 请求的工作还是应用层处理。应用层发送一个 HTTP 请求报文，交给了传输层，通过 TCP/IP 的三次握手进行请求连接。
5. 经过三次握手完成了请求的连接，客户端跟服务端就可以传输数据，客户端拿到 HTML 文档就开始渲染
##### 2、页面渲染阶段
1. 客户端浏览器的网络线程拿到 HTML 文档之后，会产生一个渲染任务，将其交给渲染进程的渲染主线程消息队列；通过事件循环机制，渲染主线程取出渲染任务，开始了渲染流程，首先是 HTML 的解析阶段（parse HTML）
    * 首先拿到的 HTML 文档内容，最开始是 0/1 组成的字节流；根据文件的编码格式，比如说是 UTF-8，将字节流转换成字符流；
    * 接着会进行词法解析，将连在一起的字符解析成词，也叫做 token；
      > 比如下面这个标签例子，当拿到字符流的时候，这些字符都是连在一起的，所以需要解析才能明白具体的含义；比如看到 <div 表示是一个标签的开始，接着看到 class="test" 表示是标签的类名，以此类推。
    ```javascript
    <div class="test">test<div/>
    ```
    * 词法解析完成后，就进行语法解析，对得到的词进行节点的创建，通过父子、兄弟关系进行节点的连接，就得到了 DOM 树；
    * 而对于 CSS，当解析遇到 link 标签引用的外部 CSS 样式表时，会开启网络线程对其进行请求，对拿到的 CSS 进行跟 DOM 树构建一样的过程，进行词法分析和语法分析，生成 CSSOM 树；
    * 而现在的浏览器做了进一步地优化，在解析 HTML 文档时，渲染进程会开启一个预解析线程，去快速浏览整个 HTML 文档，当遇到 link 标签引入的外部 CSS 代码时，开启网络线程去下载，然后交给预解析线程进行初步的解析，接着就交给渲染主线程继续解析处理；对 CSS 的处理过程跟 DOM 处理过程一样，也是包括词法分析和语法分析；
      > 当解析 HTML 遇到 link 标签时，渲染主线程不会等待，而是继续向后解析，因为下载和初步解析的工作交给了预解析线程。因此，CSS 代码的解析不会阻塞对 HTML 的解析
    * DOM 和 CSSOM 是可以同步进行处理形成的，一边处理 DOM 树构建，一边处理 CSSOM 树构建；
    * 通常为了样式的完整性，只有等到 CSSOM 树构建完成才会进行下一步的处理，所以即使 DOM 树构建完成，也要等待 CSSOM 树的构建完毕；
    * 当解析过程中遇到了 script 标签，也就是 js 代码，就会停止解析，去等待网络线程下载完 js 代码，以及等待 js 引擎线程去执行 js 代码，直到 js 执行完成；
      > 渲染主线程必须等待 js 执行完成的原因是，js 代码有可能去更改 DOM 结构
2. 当得到 DOM 树和 CSSOM 树之后，就进入下一个阶段，样式计算
    * 遍历 DOM 树，为 DOM 树的每一个节点计算样式，生成最终的样式；也就是 DOM 树和 CSSOM 树的结合；
    * 在这个过程中，预设值会变成绝对值，比如设置的颜色 red 会转成 rgb(255, 0, 0) 值，相对单位 em/rem 转成绝对单位 px；
    * 得到带有样式的 DOM 树；
3. 得到带有样式的 DOM 树之后，就进入到布局 layout 阶段
    * 在这个阶段，对 DOM 树进行进一步处理，计算每一个节点的几何信息，包括宽高、位置等，就是去计算在视口内的确切位置和大小，得到 layout 树；
    * DOM 树和 layout 树是不一样的，因为有些节点设置了 display: none，那么在 layout 树中该节点就不存在；有些节点带有 :: before/::after 伪元素，那么在 layout 树中会多渲染出一个节点
4. 接下来对布局树进行分层
    * 分层其实是浏览器在渲染时的一种优化，就是为了避免当页面滚动，或者只是某一部分发生变化时，整个页面需要重新渲染；
    * 当进行分层之后，某一个层发生改变之后，相对应地去修改该层就可以了；
    * 具体的分层策略各种浏览器可能都不一样，滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果
      > 浏览器有一个 layout/图层 选项可以查看页面的分层效果
5. 接着是绘制阶段
    * 渲染主线程为每一层生成绘制指令集，也就是为每个要渲染的元素生成一条条的指令，说明要如何绘制，位置是从哪里到哪里，背景颜色如何等等；
6. 分块
    * 当渲染主线程的绘制阶段完成之后，就将接下来的渲染任务交给了合成线程，也就是说渲染主线程的任务就是解析 HTML、样式计算、layout 布局、分层以及绘制；
    * 合成线程会开启多个子线程进行分块操作，将各图层划分为更多的小区域
7. 光栅化
    * 分块之后，合成线程将每个块信息交给 GPU 进程，由 GPU 进程完成光栅化；
    * 光栅化，也就是生成一个个位图，也就是生成图像的像素数组，用来表示图像每个像素的具体信息；
    * 会优先处理靠近视口位置的块
8. 完成光栅化，之后就是画 draw，在页面上显示
    * 合成线程生成位图之后，将其交给浏览器的 GPU 进程，由 GPU 进程进行系统调用，交由系统硬件进行绘画，最终在屏幕上显示；
    * 同时合成线程也会考虑到旋转、缩放等变形操作；因此 transform 变形操作是发生在合成线程的
      > transform 效率高的本质原因，就是 transform 进行的过程不在渲染主线程，而是在渲染的最后一步，与渲染主线程无关
##### 3、reflow（重排/回流）和 repaint（重绘）
1. 重排：也就是元素的宽高、位置信息等影响了布局的要素发生了变化，那么就需要重新进行渲染过程中的 layout 布局这一过程，那么依次后面的分层、绘制、分块、光栅化、画几个阶段都会重新进行
2. 重绘：但修改了文字、颜色等不影响布局的要素时，浏览器重新进行渲染过程中的绘制过程，那么影响的阶段就是绘制、分块、光栅化、画
3. 重排一定引起重绘；重绘不一定引起重排






